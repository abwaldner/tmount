#!/usr/bin/env expect

  proc Dlg { Res args } {
    upvar $Res R
    set L { --title tmount --window-icon /usr/share/pixmaps/tmount.png }
    set R [
      if [ set C [ catch { exec qarma 2>/dev/null {*}$L {*}$args } S ] ] {
        puts stderr [ regsub {^child .*abnormally$} $S Cancelled. ]
      } else { set S
      };#fi
    ]
    return $C
  };# Dlg

  proc Psw { Prompt } {
    if [ Dlg P --entry --hide-text --text $Prompt ] { set P "\004" };#fi
    return "${P}\n"
  };# Psw

  proc ShLit { S } { return "'[ regsub -all {'+} $S {'"&"'} ]'"
  };# ShLit - substitutes a literal in 'su -c' (or 'sh -c') argument

  set RetC 0 ; set Map [ lindex $argv 0 ]
  set M [ exec lsblk -no MOUNTPOINT "/dev/mapper/${Map}" ]

  if { $M ne {} } {
    set Cmd TMOUNT_Unmount_command
    set Cmd [ expr { [ info exist env($Cmd) ] ? $env($Cmd) : {} } ]
    if { $Cmd eq {} } {
      puts stderr "${Map} mounted on ${M} and unmount disabled by config."
      set RetC 1
    } else { set RetC [ catch { exec -ignorestderr -- {*}$Cmd $M } ]
    };#fi
  };#fi

  if { ! $RetC } {
    set Cmd "/sbin/cryptsetup close [ ShLit ${Map} ]"
    set timeout -1 ; log_user 0 ; set env(LC_ALL) {C} ; set Err {}
    spawn su -c $Cmd
    expect {
      {^Password: } {
        exp_send [ Psw {su: Enter root password} ] ; exp_continue
      }
      full_buffer { append Err $expect_out(buffer) ; exp_continue }
      eof { append Err $expect_out(buffer) }
    }
    set RetC [ lrange [ wait ] 3 3 ]
    if { $RetC } { puts stderr $Err } else { puts "${Map} released." };#fi
  };#fi

exit $RetC
