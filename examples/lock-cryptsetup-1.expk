#!/usr/bin/env wish

  package require Expect

  set Cmd /sbin/cryptsetup

  proc Dlg {} {
   global RetC
   set x [ expr { [ winfo screenwidth   . ] - [ winfo reqwidth  . ] } ]
   set x [ expr { $x / 2 - [ winfo vrootx . ] } ]
   set y [ expr { [ winfo screenheight  . ] - [ winfo reqheight . ] } ]
   set y [ expr { $y / 2 - [ winfo vrooty . ] } ]
   wm geom . +$x+$y ; wm deiconify . ; focus .ent ; tkwait var RetC
   catch { wm withdraw . } ; if { $RetC } { puts stderr Cancelled. };#fi
   return $RetC
  };# Dlg

  proc ShLit { S } { return "'[ regsub -all {'+} $S {'"&"'} ]'"
  };# ShLit - substitutes a literal in 'su -c' (or 'sh -c') argument

  proc Prop { Dev N } { ;# get property for device
    if [ catch { exec lsblk -no $N $Dev } P ] { set P {} };#fi
    return [ set P ]
  }

  set RetC 0 ; set Map [ lindex $argv 0 ] ; set EOF "\004"
  set Cmd "${Cmd} close [ ShLit $Map ]"
  set Lnk "/dev/mapper/${Map}"
  set C TMOUNT_Unmount_command
  set C [ expr { [ info exist env($C) ] ? $env($C) : {} } ]
  regsub {^$} $C { sh -c "! echo Unmount disabled by config >\&2" } C

  while { ! $RetC && [ set M [ Prop $Lnk MOUNTPOINT ] ] ne {} } {
    set RetC [ catch { exec -ignorestderr -- {*}$C $M } ]
  }

  if { ! $RetC } {

    wm withdraw . ; wm title . tmount ; label .lbl ; frame .btn
    wm iconphoto . [ image create photo -file /usr/share/pixmaps/tmount.png ]
    bind . <Escape> { set RetC 1 } ; bind . <Destroy> { set RetC 1 }
    button .ok  -text OK     -command { set RetC 0 }
    button .esc -text Cancel -command { set RetC 1 }
    bind   .ok  <Return> { set RetC 0 } ; bind .esc <Return> { set RetC 1 }
    pack   .esc .ok -side right -in .btn
    entry  .ent -show {*} -textvar Psw  ; bind .ent <Return> { set RetC 0 }
    .lbl   configure -text {su: Enter root password}
    pack   .lbl .ent .btn -fill x -padx 2
    set timeout -1 ; log_user 0 ; set env(LC_ALL) {C} ; set Err {}

    spawn su -c $Cmd
    expect {
      {^Password: } {
        if [ Dlg ] { set Psw $EOF };#fi
        exp_send "${Psw}\n" ; exp_continue
      }
      full_buffer { append Err $expect_out(buffer) ; exp_continue }
      eof { append Err $expect_out(buffer) }
    }
    set RetC [ lrange [ wait ] 3 3 ]

    if { $RetC } { puts stderr $Err } else { puts "${Map} released." };#fi

  };#fi

exit $RetC
