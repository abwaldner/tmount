#!/usr/bin/env expect

  set Cmd /sbin/cryptsetup

  proc Dlg { Res args } {
    upvar $Res R
    set L { --title tmount --window-icon /usr/share/pixmaps/tmount.png }
    set R [
      if [ set C [ catch { exec qarma 2>/dev/null {*}$L {*}$args } S ] ] {
        puts stderr [ regsub {^child .*abnormally$} $S Cancelled. ]
      } else { set S
      };#fi
    ]
    return $C
  };# Dlg

  proc Mode {} {
    Dlg M --forms --text {LUKS passphrase input method:} \
          --add-combo Select --combo-values {Interactive|Key File}
    return [ string tolower [ string range $M 0 0 ] ]
  };# Mode

  proc Psw { Prompt } {
    if [ Dlg P --entry --hide-text --text $Prompt ] { set P "\004" };#fi
    return "${P}\n"
  };# Psw

  proc FSel {} {
    Dlg F --file-selection --title {tmount - Select a key file}
    return $F
  };# FSel

  proc ShLit { S } { return "'[ regsub -all {'+} $S {'"&"'} ]'"
  };# ShLit - substitutes a literal in 'su -c' (or 'sh -c') argument

  proc NoFS { Dev } {
    set P {E: ID_FS_USAGE=filesystem}
    return [ catch { exec udevadm info $Dev | grep -Fxq $P } ]
  };# NoFS

  proc GenMN { Dev } { ;# generate cryptsetups map name
    set M [ file tail $Dev ]
    set M [ regsub -all {[^[:alnum:]#+-.:=@]|[^[:ascii:]]} $M {_} ]
    return [ exec mktemp -u -p /dev/mapper "${M}-XXX" ]
  };# GenMN

  set RetC 1 ; set SN [ info script ]
  set Dev [ lindex $argv end ]
  set Lnk [ GenMN $Dev ] ; set Map [ file tail $Lnk ]
  set Cmd "${Cmd} open [ ShLit $Dev ] [ ShLit $Map ]"
  set Mode [
    set M [ lindex $argv 0 ]
    if { $argc == 2 && $M in { -k -i -a } } { string range $M 1 1
    } elseif { $argc == 1 } { expr {{a}}
    };#fi
  ]

  if { $Mode eq {} } {
    puts stderr [
      format {Usage: %s [-k|-i|-a] {device|file}} [ file tail $SN ]
    ]
  };#fi

  if { $Mode eq {a} } { set Mode [ Mode ] };#fi

  if { $Mode eq {k} } { set Mode [ FSel ] ; append Cmd " -d [ ShLit $Mode ]"
  };#fi

  if { $Mode ne {} } {

    set timeout -1 ; log_user 0 ; set env(LC_ALL) {C} ; set Err {}

    spawn su -c $Cmd
    expect {
      {^Password: } {
        exp_send [ Psw {su: Enter root password} ] ; exp_continue
      }
      {Enter passphrase for *: } {
        exp_send [ Psw "Enter LUKS passphrase for ${Dev}" ] ; exp_continue
      }
      full_buffer { append Err $expect_out(buffer) ; exp_continue }
      eof { append Err $expect_out(buffer) }
    }
    set RetC [ lrange [ wait ] 3 3 ]

    if { $RetC } { puts stderr $Err
    } else {
      set F {} ; set S {} ; set L {(no label)} ; set R [ exec realpath $Lnk ]
      set X "Device %s mapped to %s.\n%s -> %s\n%s (%s, \[%s], %s)\n"
      scan [ exec lsblk -no FSTYPE,SIZE,LABEL $Lnk ] {%s%s%s} F S L
      puts [ format $X $Dev $Map $Lnk $R [ file tail $R ] $F $L $S ]
      set C TMOUNT_Mount_command
      set C [ expr { [ info exist env($C) ] ? $env($C) : {} } ]
      if { ! [ NoFS $R ] && $C ne {} } {
        set RetC [ catch { exec -ignorestderr -- {*}$C $R } ]
        puts "mounted on [ exec lsblk -no MOUNTPOINT $R ]"
      };#fi
    };#fi

  };#fi

exit $RetC
